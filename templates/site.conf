#! /bin/bash

#
#  Helper Bash Script of Gluon Puppet module
# ... creating a gluon site/site.conf
#
# This script just performs some ip address calculations,
# fetches fastd's public key and fills the template
# (after ERB filled the directly known stuff already).
#
# Ip calculation helper functions for bash taken from
# http://www.linuxquestions.org/questions/programming-9/bash-cidr-calculator-646701/
netcalc(){
    local IFS='.' ip i
    local -a oct msk

    read -ra oct <<<"$1"
    read -ra msk <<<"$2"

    for i in ${!oct[@]}; do
        ip+=( "$(( oct[i] & msk[i] ))" )
    done

    echo "${ip[*]}"
}

mask2cidr() {
    local nbits dec
    local -a octets=( [255]=8 [254]=7 [252]=6 [248]=5 [240]=4 [224]=3 [192]=2 [128]=1 [0]=0 )

    while read -rd '.' dec; do
        [[ -z ${octets[dec]} ]] && echo "Error: $dec is not recognised" && exit 1
        (( nbits += octets[dec] ))
        (( dec < 255 )) && break
    done <<<"$1."

    echo "$nbits"
}

ip4_net="`netcalc "<%= @ip4_address %>" "<%= @ip4_netmask %>"`"
ip4_cidr=`mask2cidr "<%= @ip4_netmask %>"`

last="${ip4_net#*.*.*.}"
next_node_ip4="${ip4_net%$last}$[$last + 1]"

cat << EOF
{
	hostname_prefix = 'freifunk-',
	site_name = '<%= @site_name %>',
	site_code = '<%= @community %>',
	domain_seed = '<%= @domain_seed %>',

	prefix4 = '$ip4_net/$ip4_cidr',
	prefix6 = '<%= @ip6_prefix %>/64',

	timezone = 'CET-1CEST,M3.5.0,M10.5.0/3', -- Europe/Berlin
	ntp_servers = {'<%= @ntp_server %>'},
	regdom = 'DE',

	mesh = {
		vxlan = false,
		batman_adv = {
			gw_sel_class = 20,
		},
	},
	wifi24 = {
		channel = 1,
		supported_rates = {12000, 18000, 24000, 36000, 48000, 54000},
		basic_rate = {12000},
		ap = {
			ssid = '<%= @ssid.downcase %>',
		},
		mesh = {
			id = '<%= @community %>-mesh',
			mcast_rate = 12000,
		},
	},
	wifi5 = {
		channel = 44,
		ap = {
			ssid = '<%= @ssid.downcase %>',
		},
		mesh = {
			id = '<%= @community %>-mesh',
			mcast_rate = 12000,
		},
	},

	next_node = {
		ip4 = '$next_node_ip4',
		ip6 = '<%= @ip6_prefix %>1',

		mac = '42:ca:ff:ee:ba:be',
	},

	mesh_vpn = {
		mtu = <%= @mtu %>,
		fastd = {
			methods = {'<%= @cipher %>'},
			groups = {
                                ipvsix = {
                                        limit = 1,
                                        peers = {
EOF
(
cd <%= @peers_dir %>
gawk "/key/ { key = substr(\$2, 2, 64) } /remote/ { if(match(\$2, /([^:]+):([0-9]+)/, arr)) { ip = arr[1]; port = arr[2]; } remote = \$2 } END { if(ip && port) { print \"<%= @ip6_gateway %> = {\n\tkey = '\"key\"',\n\tremotes = { 'ipv4 \\\"\"ip\"\\\" port \"port\"' },\n}, \" } }" < <%= @ip6_gateway %>
)
cat <<EOF
                                        },
                                },
				backbone = {
					limit = 1,
					peers = {
EOF
(
cd <%= @peers_dir %>
for fn in *; do
  [ "$fn" == "<%= @ip6_gateway %>" ] && continue
  gawk "/key/ { key = substr(\$2, 2, 64) } /remote/ { if(match(\$2, /([^:]+):([0-9]+)/, arr)) { ip = arr[1]; port = arr[2]; } remote = \$2 } END { if(ip && port) { print \"$fn = {\n\tkey = '\"key\"',\n\tremotes = { 'ipv4 \\\"\"ip\"\\\" port \"port\"' },\n}, \" } }" < $fn
done
)
cat <<EOF
					},
				},
			},
		},
		bandwidth_limit = {
			enabled = false,
			egress = 200,
			ingress = 3000,
		},
	},

	autoupdater = {
		enabled = '1',
		branch = 'stable',
		branches = {
			stable = {
				name = 'stable',
				mirrors = {'http://[<%= @ip6_address %>]/firmware/stable/sysupgrade/'},
				good_signatures = 1,
				pubkeys = {'<%= @auto_update_pubkey %>',
				},
			},
			experimental = {
				name = 'experimental',
				mirrors = {'http://[<%= @ip6_address %>]/firmware/experimental/sysupgrade/'},
				good_signatures = 1,
				pubkeys = {'<%= @auto_update_pubkey %>',
				},
			},
		},
	},

	setup_mode = {
		skip = false,
	},

	config_mode = {
		geo_location = {
			show_altitude = false,
		},
		remote_login = {
			show_password_form = true,
			min_password_length = 10,
		},
	},
}
EOF
